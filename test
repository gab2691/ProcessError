import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class FileServiceTest {

    @InjectMocks
    private FileService fileService;

    @Mock
    private ClassPathResource mockResource;

    @BeforeEach
    void setUp() {
        // Configuração leniente para evitar o aviso de "unnecessary stubbings"
        String jsonContent = "{\"key\": \"value\"}";
        InputStream inputStream = new ByteArrayInputStream(jsonContent.getBytes(StandardCharsets.UTF_8));

        lenient().when(mockResource.exists()).thenReturn(true);
        lenient().when(mockResource.getInputStream()).thenReturn(inputStream);

        // Define os valores necessários para as propriedades anotadas com @Value na classe FileService
        ReflectionTestUtils.setField(fileService, "directoryFile", "C:\\Users\\T734536\\OneDrive - Santander Office 365\\Documents\\Workspace\\MDrepo\\docs\\docs");
        ReflectionTestUtils.setField(fileService, "mapPath", "/path/to/map-links-file");
        ReflectionTestUtils.setField(fileService, "treeViewFile", "/path/to/treeView-file");
    }

    @Test
    void init_FileExists_MapFileIsLoaded() {
        fileService.init();
        assertNotNull(fileService.getMapFile());
        assertFalse(fileService.getMapFile().isEmpty());
        assertEquals("value", fileService.getMapFile().get("key"));
    }

    @Test
    void saveFile_SuccessfullySavesFile() throws Exception {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            fileService.saveFile("test data", "/test/path", "testFile");
            mockedFiles.verify(() -> Files.write(any(Path.class), eq("test data".getBytes(StandardCharsets.UTF_8))), times(1));
        }
    }

    @Test
    void saveFile_ThrowsSaveFileException() {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            mockedFiles.when(() -> Files.write(any(Path.class), any(byte[].class))).thenThrow(IOException.class);
            assertThrows(SaveFileException.class, () -> fileService.saveFile("test data", "/test/path", "testFile"));
        }
    }
@Test
    void transformFileInObject_WithValidFile_SuccessfullyTransforms(@TempDir Path tempDir) throws IOException {
        // Criar um arquivo temporário e escrever conteúdo nele
        Path tempFile = tempDir.resolve("tempFile.json");
        String jsonContent = "{\"name\":\"Test Name\"}";
        Files.write(tempFile, jsonContent.getBytes());

        // Teste com uma classe de exemplo que corresponda ao JSON
        ExampleClass result = fileService.transformFileInObject(tempFile.toString(), ExampleClass.class);

        assertNotNull(result);
        assertEquals("Test Name", result.getName());
    }

    @Test
    void transformFileInObject_WithInvalidInput_ThrowsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> 
            fileService.transformFileInObject(null, null));
    }

    @Test
    void transformFileInObject_FileNotAccessible_ThrowsFileNotAccessibleException() {
        String nonExistentFilePath = "nonexistentfile.json";
        assertThrows(FileNotAccessibleException.class, () -> 
            fileService.transformFileInObject(nonExistentFilePath, ExampleClass.class));
    }
@Test
    void transformInputStreamInObject_WithValidInputStream_SuccessfullyTransforms() throws Exception {
        String jsonContent = "{\"name\":\"Test Name\"}";
        InputStream inputStream = new ByteArrayInputStream(jsonContent.getBytes(StandardCharsets.UTF_8));

        ExampleClass result = fileService.transformInputStreamInObject(inputStream, ExampleClass.class);

        assertNotNull(result);
        assertEquals("Test Name", result.getName());
    }

    @Test
    void transformInputStreamInObject_WithInvalidInput_ThrowsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(null, ExampleClass.class),
                "Passing null inputStream should throw IllegalArgumentException");

        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(new ByteArrayInputStream(new byte[0]), null),
                "Passing null clazz should throw IllegalArgumentException");
    }

    @Test
    void transformInputStreamInObject_WhenIOExceptionOccurs_ThrowsIllegalArgumentException() throws Exception {
        InputStream failingInputStream = new InputStream() {
            @Override
            public int read() throws IOException {
                throw new IOException("Forced IOException for test");
            }
        };

        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(failingInputStream, ExampleClass.class),
                "IOException during readValue should result in IllegalArgumentException");
    }

@Test
    void modifyDirectory_SuccessfullyModifiesDirectory() {
        // Preparar dados de teste
        List<TreeViewDTO> initialTreeView = Arrays.asList(
            new TreeViewDTO("Title1", "url1/child1", null, null, 1, false),
            new TreeViewDTO("Title2", "url2/child2", null, null, 2, false)
        );
        SidenavDTO mockSidenavDTO = new SidenavDTO("Title", "url", initialTreeView);

        // Mockar transformFileInObject para retornar mockSidenavDTO
        fileService = spy(fileService); // Usar spy para permitir mock parcial
        doReturn(mockSidenavDTO).when(fileService).transformFileInObject(anyString(), eq(SidenavDTO.class));

        // Executar
        List<TreeViewDTO> modified = fileService.modifyDirectory();

        // Verificar
        assertNotNull(modified);
        assertFalse(modified.isEmpty());
        
        // Assumindo que a função dfsGetLastDirectory modifica a URL para remover qualquer segmento após o último '/'
        // Aqui você precisa ajustar a lógica de asserção conforme o que a sua função dfsGetLastDirectory faz exatamente
        for (TreeViewDTO dto : modified) {
            assertFalse(dto.getUrl().contains("/"), "URL modificada não deve conter '/': " + dto.getUrl());
        }
    }

    @Test
    void modifyDirectory_ModifiesUrlsCorrectly() {
        // Preparando dados simulados
        List<TreeViewDTO> childrenList = new ArrayList<>();
        childrenList.add(new TreeViewDTO("Child Title", "parent/child", null, new ArrayList<>(), 1, false));
        List<TreeViewDTO> initialTreeView = new ArrayList<>();
        initialTreeView.add(new TreeViewDTO("Parent Title", "parent", null, childrenList, 0, true));
        SidenavDTO mockSidenavDTO = new SidenavDTO("Main Title", "/main", initialTreeView);

        // Configuração do mock para transformFileInObject
        fileService = spy(fileService);
        doReturn(mockSidenavDTO).when(fileService).transformFileInObject(anyString(), eq(SidenavDTO.class));

        // Execução
        List<TreeViewDTO> modified = fileService.modifyDirectory();

        // Verificações
        assertNotNull(modified);
        assertFalse(modified.isEmpty());

        assertEquals("parent", modified.get(0).getUrl(), "A URL do pai deve ser modificada para o último segmento");
        assertEquals("child", modified.get(0).getChildren().get(0).getUrl(), "A URL da criança deve ser modificada para o último segmento");
    }

@Test
    void comparePaths_MatchingPaths_ReturnsTrue() {
        // Caminho que termina exatamente com o nome do arquivo/folder esperado
        String directory = "C:\\Users\\example\\Documents\\folder";
        Path folder = Paths.get("folder");

        boolean result = fileService.comparePaths(directory, folder);

        assertTrue(result, "O método deveria retornar true quando os caminhos correspondem.");
    }

    @Test
    void comparePaths_NonMatchingPaths_ReturnsFalse() {
        // Caminho que não termina com o nome do arquivo/folder esperado
        String directory = "C:\\Users\\example\\Documents\\folder";
        Path folder = Paths.get("differentFolder");

        boolean result = fileService.comparePaths(directory, folder);

        assertFalse(result, "O método deveria retornar false quando os caminhos não correspondem.");
    }

    // Opcional: Testes para casos de borda, como strings vazias ou nulas
    @Test
    void comparePaths_WithEmptyOrNullOrPath_ReturnsFalse() {
        String directoryEmpty = "";
        String directoryNull = null;
        Path folder = Paths.get("folder");
        Path nullFolder = null;

        // Testando com diretório vazio
        assertFalse(fileService.comparePaths(directoryEmpty, folder), "Deveria retornar false para diretório vazio.");
        
        // Testando com diretório nulo - Este caso esperaria uma NullPointerException baseado na implementação atual
        // Se o comportamento desejado for diferente, o método comparePaths precisaria ser ajustado para lidar com null
        assertThrows(NullPointerException.class, () -> fileService.comparePaths(directoryNull, folder), "Deveria lançar NullPointerException para diretório nulo.");
        
        // Testando com folder nulo - Comportamento esperado baseado na implementação atual
        assertFalse(fileService.comparePaths(directoryEmpty, nullFolder), "Deveria retornar false para folder nulo.");
    }
}
