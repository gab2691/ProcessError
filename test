import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class FileServiceTest {

    @InjectMocks
    private FileService fileService;

    @Mock
    private ClassPathResource mockResource;

    @BeforeEach
    void setUp() {
        // Configuração leniente para evitar o aviso de "unnecessary stubbings"
        String jsonContent = "{\"key\": \"value\"}";
        InputStream inputStream = new ByteArrayInputStream(jsonContent.getBytes(StandardCharsets.UTF_8));

        lenient().when(mockResource.exists()).thenReturn(true);
        lenient().when(mockResource.getInputStream()).thenReturn(inputStream);

        // Define os valores necessários para as propriedades anotadas com @Value na classe FileService
        ReflectionTestUtils.setField(fileService, "directoryFile", "C:\\Users\\T734536\\OneDrive - Santander Office 365\\Documents\\Workspace\\MDrepo\\docs\\docs");
        ReflectionTestUtils.setField(fileService, "mapPath", "/path/to/map-links-file");
        ReflectionTestUtils.setField(fileService, "treeViewFile", "/path/to/treeView-file");
    }

    @Test
    void init_FileExists_MapFileIsLoaded() {
        fileService.init();
        assertNotNull(fileService.getMapFile());
        assertFalse(fileService.getMapFile().isEmpty());
        assertEquals("value", fileService.getMapFile().get("key"));
    }

    @Test
    void saveFile_SuccessfullySavesFile() throws Exception {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            fileService.saveFile("test data", "/test/path", "testFile");
            mockedFiles.verify(() -> Files.write(any(Path.class), eq("test data".getBytes(StandardCharsets.UTF_8))), times(1));
        }
    }

    @Test
    void saveFile_ThrowsSaveFileException() {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            mockedFiles.when(() -> Files.write(any(Path.class), any(byte[].class))).thenThrow(IOException.class);
            assertThrows(SaveFileException.class, () -> fileService.saveFile("test data", "/test/path", "testFile"));
        }
    }
@Test
    void transformFileInObject_WithValidFile_SuccessfullyTransforms(@TempDir Path tempDir) throws IOException {
        // Criar um arquivo temporário e escrever conteúdo nele
        Path tempFile = tempDir.resolve("tempFile.json");
        String jsonContent = "{\"name\":\"Test Name\"}";
        Files.write(tempFile, jsonContent.getBytes());

        // Teste com uma classe de exemplo que corresponda ao JSON
        ExampleClass result = fileService.transformFileInObject(tempFile.toString(), ExampleClass.class);

        assertNotNull(result);
        assertEquals("Test Name", result.getName());
    }

    @Test
    void transformFileInObject_WithInvalidInput_ThrowsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> 
            fileService.transformFileInObject(null, null));
    }

    @Test
    void transformFileInObject_FileNotAccessible_ThrowsFileNotAccessibleException() {
        String nonExistentFilePath = "nonexistentfile.json";
        assertThrows(FileNotAccessibleException.class, () -> 
            fileService.transformFileInObject(nonExistentFilePath, ExampleClass.class));
    }
}
