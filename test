@Slf4j
@Service
public abstract class FileService {

    private HashMap<String, String> mapFile;

    @Value("${directory.map-links-file}")
    private String mapPath;

    @Value("${GIT_REPO_PATH:C:\\Users\\T734536\\OneDrive - Santander Office 365\\Documents\\Workspace\\MDrepo\\docs\\docs}")
    private String directoryFile;

    @Value("${directory.treeView-file}")
    private String treeViewFile;

    @PostConstruct
    public void init() {
        Resource resource = new ClassPathResource("static/map-link.json");
        if (resource.exists()) {
            try (InputStream inputStream = resource.getInputStream()) {
                this.mapFile = transformInputStreamInObject(inputStream, HashMap.class);
            } catch (IOException e) {
                log.error("Não foi possível carregar o arquivo de mapeamento", e);
            }
        } else {
            log.error("O arquivo de mapeamento não foi encontrado no classpath");
        }
    }

    public void saveFile(String data, String path, String fileName) {
        log.info("Saving file {} in Path {}", fileName, path);

        String fileNameNormalize = Normalizer.normalize(fileName, Normalizer.Form.NFD)
            .replaceAll("[^\\p{ASCII}]", "");

        log.info("Filename normalize, old name, {} new name {}", fileName, fileNameNormalize);

        Path basePath = Paths.get(directoryFile);
        path = path.substring(1);

        String[] segments = path.split("/");
        Path directoryPath;

        if (segments.length == 2) {
            directoryPath = basePath.resolve(segments[0]);
        } else {
            directoryPath = basePath.resolve(path).getParent();
        }

        Path finalPath = directoryPath.resolve(treatingDocName(fileNameNormalize) + ".md");

        try {
            Files.write(finalPath, data.getBytes(StandardCharsets.UTF_8));
        } catch (SaveFileException | IOException e) {
            log.error("Error tryng saving file {} in Path {}", treatingDocName(fileNameNormalize),
                path);
            throw new SaveFileException("Error to save file: " + e.getMessage());
        }
    }

    public <T> T transformFileInObject(String filePath, Class<T> clazz) {
        if (filePath == null || filePath.isEmpty() || clazz == null) {
            log.warn("Invalid input: filePath = {}, clazz = {}", filePath, clazz);
            throw new IllegalArgumentException(
                "File directory or class, not available or no exists");
        }

        File file = new File(filePath);
        if (!file.exists() || !file.canRead()) {
            log.warn("Error tryng transform file {} into class {}", file, clazz);
            throw new FileNotAccessibleException("File or class, not available or no exists");
        }
        log.info("Getting file {} from directory {} and transform into class {}", file.getName(),
            directoryFile, clazz);

        try {
            log.info("Transform file {} into Class {}", filePath, clazz);
            return new ObjectMapper().readValue(file, clazz);
        } catch (IOException e) {
            log.error("Error trying transform file {} to Object {} due to IOException", file.getName(), clazz, e);
            throw new IllegalArgumentException("Error trying to create Object from file, verify the file and class", e);
        } catch (IllegalArgumentException e) {
            log.error("Error trying transform file {} to Object {} due to IllegalArgumentException", file.getName(), clazz, e);
            throw e;
        }
    }


    public <T> T transformInputStreamInObject(InputStream inputStream, Class<T> clazz) {
        if (inputStream == null || clazz == null) {
            log.warn("Invalid input: inputStream = {}, clazz = {}", inputStream, clazz);
            throw new IllegalArgumentException(
                "InputStream or class not available or does not exist");
        }

        try {
            log.info("Transforming InputStream into class {}", clazz);
            ObjectMapper objectMapper = new ObjectMapper();
            return objectMapper.readValue(inputStream, clazz);
        } catch (IOException e) {
            log.error("Error transforming InputStream to object", e);
            throw new IllegalArgumentException("Error trying to create object from InputStream", e);
        }
    }


    public List<TreeViewDTO> modifyDirectory() {
        List<TreeViewDTO> sidenav = this.transformFileInObject(treeViewFile, SidenavDTO.class)
            .getSidenav();
        dfsGetLastDirectory(sidenav);
        return sidenav;
    }


    private void dfsGetLastDirectory(List<TreeViewDTO> sidenav) {
        if (sidenav == null) {
            return;
        }

        for (TreeViewDTO t : sidenav) {
            if (t.getUrl() != null) {
                String url = t.getUrl();
                String[] split = url.split("/");
                t.setUrl(split[split.length - 1]);

                dfsGetLastDirectory(t.getChildren());
            }
        }
    }


    public boolean comparePaths(String directory, Path folder) {
        return Paths.get(directory).getFileName().endsWith(folder);
    }


    public void updateTreeView(List<TreeViewDTO> treeViewDTO) {
        log.info("Saving new version of TreeView in folder {}", treeViewFile);
        try {
            new ObjectMapper().writeValue(new File(treeViewFile),
                new SidenavDTO("Java", "/docs/java", treeViewDTO));
        } catch (IOException e) {
            log.error("Error trying to update file TreeView", e);
            throw new UpdateTreeViewFile("Error trying to update file TreeView", e); // Altere o construtor de UpdateTreeViewFile para aceitar uma causa
        }
    }

    
    public SidenavDTO createNewFolder(FolderDTO folderDTO) throws FolderCreationException {
        SidenavDTO sidenavDTO = this.transformFileInObject(treeViewFile, SidenavDTO.class);
        TreeViewDTO treeViewDTO = findFolder(sidenavDTO.getSidenav(), folderDTO.findLastPath());
        if (treeViewDTO == null) {
            throw new FolderCreationException(
                "This basePath doesn't exist: " + folderDTO.getBasePath());
        }
        Path path = Paths.get(directoryFile);
        try {
            String pathString =
                new StringBuilder(path.toString())
                    .append("/")
                    .append(treeViewDTO.getUrl())
                    .append("/" + treatingDocName(folderDTO.getFolder())).toString();

            Files.createDirectories(Path.of(pathString));

            TreeViewDTO currentTreeView =
                new TreeViewDTO(folderDTO.getFolder()
                    .replace("-", ""),
                    treeViewDTO.getUrl() + "/" + treatingDocName(folderDTO.getFolder()),
                    null, new ArrayList<>(),
                    treeViewDTO.getChildren().size() + 1, false);

            treeViewDTO.getChildren().add(currentTreeView);

            createDefaultDoc(treeViewDTO, folderDTO);
        } catch (IOException e) {
            throw new FolderCreationException("Error creating folder", e);
        }
        return sidenavDTO;
    }
