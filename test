import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.ClassPathResource;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class FileServiceTest {

    @InjectMocks
    private FileService fileService;

    @Mock
    private ClassPathResource mockResource;

    @BeforeEach
    void setUp() {
        // Configuração leniente para evitar o aviso de "unnecessary stubbings"
        String jsonContent = "{\"key\": \"value\"}";
        InputStream inputStream = new ByteArrayInputStream(jsonContent.getBytes(StandardCharsets.UTF_8));

        lenient().when(mockResource.exists()).thenReturn(true);
        lenient().when(mockResource.getInputStream()).thenReturn(inputStream);

        // Define os valores necessários para as propriedades anotadas com @Value na classe FileService
        ReflectionTestUtils.setField(fileService, "directoryFile", "C:\\Users\\T734536\\OneDrive - Santander Office 365\\Documents\\Workspace\\MDrepo\\docs\\docs");
        ReflectionTestUtils.setField(fileService, "mapPath", "/path/to/map-links-file");
        ReflectionTestUtils.setField(fileService, "treeViewFile", "/path/to/treeView-file");
    }

    @Test
    void init_FileExists_MapFileIsLoaded() {
        fileService.init();
        assertNotNull(fileService.getMapFile());
        assertFalse(fileService.getMapFile().isEmpty());
        assertEquals("value", fileService.getMapFile().get("key"));
    }

    @Test
    void saveFile_SuccessfullySavesFile() throws Exception {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            fileService.saveFile("test data", "/test/path", "testFile");
            mockedFiles.verify(() -> Files.write(any(Path.class), eq("test data".getBytes(StandardCharsets.UTF_8))), times(1));
        }
    }

    @Test
    void saveFile_ThrowsSaveFileException() {
        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            mockedFiles.when(() -> Files.write(any(Path.class), any(byte[].class))).thenThrow(IOException.class);
            assertThrows(SaveFileException.class, () -> fileService.saveFile("test data", "/test/path", "testFile"));
        }
    }
@Test
    void transformFileInObject_WithValidFile_SuccessfullyTransforms(@TempDir Path tempDir) throws IOException {
        // Criar um arquivo temporário e escrever conteúdo nele
        Path tempFile = tempDir.resolve("tempFile.json");
        String jsonContent = "{\"name\":\"Test Name\"}";
        Files.write(tempFile, jsonContent.getBytes());

        // Teste com uma classe de exemplo que corresponda ao JSON
        ExampleClass result = fileService.transformFileInObject(tempFile.toString(), ExampleClass.class);

        assertNotNull(result);
        assertEquals("Test Name", result.getName());
    }

    @Test
    void transformFileInObject_WithInvalidInput_ThrowsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () -> 
            fileService.transformFileInObject(null, null));
    }

    @Test
    void transformFileInObject_FileNotAccessible_ThrowsFileNotAccessibleException() {
        String nonExistentFilePath = "nonexistentfile.json";
        assertThrows(FileNotAccessibleException.class, () -> 
            fileService.transformFileInObject(nonExistentFilePath, ExampleClass.class));
    }
@Test
    void transformInputStreamInObject_WithValidInputStream_SuccessfullyTransforms() throws Exception {
        String jsonContent = "{\"name\":\"Test Name\"}";
        InputStream inputStream = new ByteArrayInputStream(jsonContent.getBytes(StandardCharsets.UTF_8));

        ExampleClass result = fileService.transformInputStreamInObject(inputStream, ExampleClass.class);

        assertNotNull(result);
        assertEquals("Test Name", result.getName());
    }

    @Test
    void transformInputStreamInObject_WithInvalidInput_ThrowsIllegalArgumentException() {
        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(null, ExampleClass.class),
                "Passing null inputStream should throw IllegalArgumentException");

        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(new ByteArrayInputStream(new byte[0]), null),
                "Passing null clazz should throw IllegalArgumentException");
    }

    @Test
    void transformInputStreamInObject_WhenIOExceptionOccurs_ThrowsIllegalArgumentException() throws Exception {
        InputStream failingInputStream = new InputStream() {
            @Override
            public int read() throws IOException {
                throw new IOException("Forced IOException for test");
            }
        };

        assertThrows(IllegalArgumentException.class, () ->
                fileService.transformInputStreamInObject(failingInputStream, ExampleClass.class),
                "IOException during readValue should result in IllegalArgumentException");
    }

@Test
    void modifyDirectory_SuccessfullyModifiesDirectory() {
        // Preparar dados de teste
        List<TreeViewDTO> initialTreeView = Arrays.asList(
            new TreeViewDTO("Title1", "url1/child1", null, null, 1, false),
            new TreeViewDTO("Title2", "url2/child2", null, null, 2, false)
        );
        SidenavDTO mockSidenavDTO = new SidenavDTO("Title", "url", initialTreeView);

        // Mockar transformFileInObject para retornar mockSidenavDTO
        fileService = spy(fileService); // Usar spy para permitir mock parcial
        doReturn(mockSidenavDTO).when(fileService).transformFileInObject(anyString(), eq(SidenavDTO.class));

        // Executar
        List<TreeViewDTO> modified = fileService.modifyDirectory();

        // Verificar
        assertNotNull(modified);
        assertFalse(modified.isEmpty());
        
        // Assumindo que a função dfsGetLastDirectory modifica a URL para remover qualquer segmento após o último '/'
        // Aqui você precisa ajustar a lógica de asserção conforme o que a sua função dfsGetLastDirectory faz exatamente
        for (TreeViewDTO dto : modified) {
            assertFalse(dto.getUrl().contains("/"), "URL modificada não deve conter '/': " + dto.getUrl());
        }
    }
}
